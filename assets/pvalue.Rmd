---
title: "Proteomics data analysis: cancer example 6x6"
author: "Lieven Clement"
date: "statOmics, Ghent University (https://statomics.github.io)"
output:
    html_document:
      code_download: true
      theme: cosmo
      toc: true
      toc_float: true
      highlight: tango
      number_sections: true
---

# Background

A study on the facultative pathogen Francisella tularensis was conceived by Ramond et al. (2015) [12]. F. tularensis enters the cells of its host by phagocytosis. The authors showed that F. tularensis is arginine deficient and imports arginine from the host cell via an arginine transporter, ArgP, in order to efficiently escape from the phagosome and reach the cytosolic compartment, where it can actively multiply. In their study, they compared the proteome of wild type F. tularensis (WT) to ArgP-gene deleted F. tularensis (knock-out, D8). For this exercise, we use a subset of the F. tularensis dataset where bacterial cultures were grown in biological triplicate and each sample was run on a nanoRSLC-Q Exactive PLUS instrument. The data were searched with MaxQuant version 1.4.1.2.
The data can be found on [https://github.com/statOmics/SGA2020/tree/data](https://github.com/statOmics/SGA2020/tree/data).

# Data

We first import the peptides.txt file. This is the file that contains your peptide-level intensities. For a MaxQuant search [6], this peptides.txt file can be found by default in the "path_to_raw_files/combined/txt/" folder from the MaxQuant output, with "path_to_raw_files" the folder where raw files were saved. In this tutorial, we will use a MaxQuant peptides file from MaxQuant that can be found in the data tree of the SGA2020 github repository https://github.com/statOmics/SGA2020/tree/data/quantification/francisella .

To import the data we use the `QFeatures` package.

We generate the object peptideRawFile with the path to the peptideRaws.txt file.
Using the `grepEcols` function, we find the columns that contain the expression
data of the peptideRaws in the peptideRaws.txt file.

```{r, warning=FALSE, message=FALSE}
library(tidyverse)
library(limma)
library(QFeatures)
library(msqrob2)
library(plotly)

#peptidesFile <- "https://raw.githubusercontent.com/statOmics/SGA2020/data/quantification/francisella/peptides.txt"

peptidesFile <- "~/Dropbox/proteomicsShortcourse/pda2019/data/quantification/francisella/peptides.txt"

ecols <- MSnbase::grepEcols(
  peptidesFile,
  "Intensity ",
  split = "\t")

pe <- readQFeatures(
  table = peptidesFile,
  fnames = 1,
  ecol = ecols,
  name = "peptideRaw", sep="\t")

pe
pe[["peptideRaw"]]
```

We will make use from data wrangling functionalities from the tidyverse package.
The %>% operator allows us to pipe the output of one function to the next function.

```{r}
colData(pe)$genotype <- substr(
  colnames(pe[["peptideRaw"]]),
  12,
  13) %>%
  unlist %>%  
  as.factor %>%
  relevel(ref="WT")
```


We calculate how many non zero intensities we have per peptide and this
will be useful for filtering.

```{r}
rowData(pe[["peptideRaw"]])$nNonZero <- rowSums(assay(pe[["peptideRaw"]]) > 0)
```


Peptides with zero intensities are missing peptides and should be represent
with a `NA` value rather than `0`.
```{r}
pe <- zeroIsNA(pe, "peptideRaw") # convert 0 to NA
```


## Data exploration

We can inspect the missingness in our data with the `plotNA()` function
provided with `MSnbase`.
`r format(mean(is.na(assay(pe[["peptideRaw"]])))*100,digits=2)`% of all peptide
intensities are missing and for some peptides we do not even measure a signal
in any sample. The missingness is similar across samples.


```{r}
MSnbase::plotNA(assay(pe[["peptideRaw"]])) +
  xlab("Peptide index (ordered by data completeness)")
```

# Preprocessing

This section preforms standard preprocessing for the peptide data. This
include log transformation, filtering and summarisation of the data.

## Log transform the data

```{r}
pe <- logTransform(pe, base = 2, i = "peptideRaw", name = "peptideLog")
limma::plotDensities(assay(pe[["peptideLog"]]))
```


## Filtering

### Handling overlapping protein groups
In our approach a peptide can map to multiple proteins, as long as there is
none of these proteins present in a smaller subgroup.

```{r}
pe[["peptideLog"]] <-
 pe[["peptideLog"]][rowData(pe[["peptideLog"]])$Proteins
 %in% smallestUniqueGroups(rowData(pe[["peptideLog"]])$Proteins),]
```

### Remove reverse sequences (decoys) and contaminants

We now remove the contaminants, peptides that map to decoy sequences, and proteins
which were only identified by peptides with modifications.

```{r}
pe[["peptideLog"]] <- pe[["peptideLog"]][rowData(pe[["peptideLog"]])$Reverse != "+", ]
pe[["peptideLog"]] <- pe[["peptideLog"]][rowData(pe[["peptideLog"]])$
Contaminant != "+", ]
```

### Remove peptides of proteins that were only identified with modified peptides

I will skip this step for the moment. Large protein groups file needed for this.

### Drop peptides that were only identified in one sample

We keep peptides that were observed at last twice.

```{r}
pe[["peptideLog"]] <- pe[["peptideLog"]][rowData(pe[["peptideLog"]])$nNonZero >= 2, ]
nrow(pe[["peptideLog"]])
```

We keep `r nrow(pe[["peptideLog"]])` peptides after filtering.

## Quantile normalize the data
```{r}
pe <- normalize(pe, i = "peptideLog", method = "quantiles", name = "peptideNorm")
```


## Explore quantile normalized data

After quantile normalisation the density curves for all samples coincide.

```{r}
limma::plotDensities(assay(pe[["peptideNorm"]]))
```

This is more clearly seen is a boxplot.

```{r,}
boxplot(assay(pe[["peptideNorm"]]), col = palette()[-1],
       main = "Peptide distribtutions after normalisation", ylab = "intensity")
```


We can visualize our data using a Multi Dimensional Scaling plot,
eg. as provided by the `limma` package.

```{r}
limma::plotMDS(assay(pe[["peptideNorm"]]), col = as.numeric(colData(pe)$genotype))
```

The first axis in the plot is showing the leading log fold changes
(differences on the log scale) between the samples.


## Summarization to protein level

We use robust summarization in aggregateFeatures. This is the default workflow of aggregateFeatures so you do not have to specifiy the argument `fun`.
However, because we compare methods we have included the `fun` argument to show the summarization method explicitely.

```{r,warning=FALSE}
pe <- aggregateFeatures(pe,
 i = "peptideNorm",
 fcol = "Proteins",
 na.rm = TRUE,
 name = "proteinRobust",
 fun = MsCoreUtils::robustSummary)
```

```{r}
plotMDS(assay(pe[["proteinRobust"]]), col = as.numeric(colData(pe)$genotype))
```

# Data Analysis

## Estimation

We model the protein level expression values using `msqrob`.
By default `msqrob2` estimates the model parameters using robust regression.  

```{r, warning=FALSE}
pe <- msqrob(object = pe, i = "proteinRobust", formula = ~genotype)
```

## Inference

First, we extract the parameter names of the model.
```{r}
getCoef(rowData(pe[["proteinRobust"]])$msqrobModels[[1]])
```

Spike-in genotype a is the reference class. So the mean log2 expression
for samples from genotype a is '(Intercept).
The mean log2 expression for samples from genotype B is '(Intercept)+genotypeD8'.
Hence, the average log2 fold change between genotype b and
genotype a is modelled using the parameter 'genotypeD8'.
Thus, we assess the contrast 'genotypeD8=0' with our statistical test.

```{r}
L <- makeContrast("genotypeD8=0", parameterNames = c("genotypeD8"))
pe <- hypothesisTest(object = pe, i = "proteinRobust", contrast = L)
```

## Plots

### Volcano-plot


```{r,warning=FALSE}
volcano <- ggplot(rowData(pe[["proteinRobust"]])$genotypeD8,
                 aes(x = logFC, y = -log10(pval), color = adjPval < 0.05)) +
 geom_point(cex = 2.5) +
 scale_color_manual(values = alpha(c("black", "red"), 0.5)) + theme_minimal()
volcano
```


### Heatmap

We first select the names of the proteins that were declared signficant.

```{r}
sigNames <- rowData(pe[["proteinRobust"]])$genotypeD8 %>%
 rownames_to_column("proteinRobust") %>%
 filter(adjPval<0.05) %>%
 pull(proteinRobust)
heatmap(assay(pe[["proteinRobust"]])[sigNames, ])
```

There are `r length(sigNames)` proteins significantly differentially expressed at the 5% FDR level.

```{r}
rowData(pe[["proteinRobust"]])$genotypeD8 %>%
  filter(adjPval<0.05)
```


# Empirical Bayes

```{r}
sd <- sapply(
  rowData(pe[["proteinRobust"]])$msqrobModels,
  getSigma) %>%
  na.exclude
sdPost <- sapply(
  rowData(pe[["proteinRobust"]])$msqrobModels,
  getSigmaPosterior) %>%
  na.exclude

qplot(sd,sdPost) +
  geom_segment(aes(x=0,y=0,xend=2,yend=2))
```


```{r warnings=FALSE}
sd <- sapply(
  rowData(pe[["proteinRobust"]])$msqrobModels,
  getSigma) %>%
  na.exclude

coefs <-
sapply(rowData(pe[["proteinRobust"]])$msqrobModels,
    function(x) getCoef(x)[1:2]
  ) %>%
  t %>%
  na.exclude
coefs0 <- coefs
coefs0[,2] <- 0


design <- model.matrix(~genotype, colData(pe))

p <- length(sd)
pi0 <- 1
f0_equalVar <- sapply(1:p,
  function(i, beta, sd, design)
  rnorm(6, mean = design %*% beta[i,], sd = 1),
  beta = coefs0,
  sd = sd,
  design = design
  ) %>%
  t
colnames(f0_equalVar) <- colnames(pe[[1]])
sims <- readQFeatures(f0_equalVar %>% as.data.frame, ecol = 1:6, name = "sim0_equalVar")
colData(sims) <- colData(pe)
sims <- msqrob(object = sims, i = "sim0_equalVar", formula = ~genotype)

sd <- sapply(
  rowData(sims[["sim0_equalVar"]])$msqrobModels,
  getSigma) %>%
  na.exclude
sdPost <- sapply(
  rowData(sims[["sim0_equalVar"]])$msqrobModels,
  getSigmaPosterior) %>%
  na.exclude

qplot(sd,sdPost) +
  geom_segment(aes(x=0,y=0,xend=2,yend=2))
```

# p-values

## Simulation under H_0.

- Mean protein intensity equals mean of the mean intensity for the WT.
- sd equals the sd for the protein.

1. Extract $\hat \sigma$ and $\beta$'s  
```{r}
sd <- sapply(
  rowData(pe[["proteinRobust"]])$msqrobModels,
  getSigma) %>%
  na.exclude

coefs <-
sapply(rowData(pe[["proteinRobust"]])$msqrobModels,
    function(x) getCoef(x)[1:2]
  ) %>%
  t %>%
  na.exclude
```

2. Set $\beta_2$ equal to 0. No FC between WT en D8 and setup design matrix

```{r}
coefs0 <- coefs
coefs0[,2] <- 0
design <- model.matrix(~genotype, colData(pe))
```

3. Simulate protein expressions for each protein from a Normal distribution with as mean the protein mean for WT and sd the sd for the protein.
```{r}
p <- length(sd)
f0 <- sapply(1:p,
  function(i, beta, sd, design)
  rnorm(6, mean = design %*% beta[i,], sd = sd[i]),
  beta = coefs0,
  sd = sd,
  design = design
  ) %>%
  t
colnames(f0) <- colnames(pe[[1]])
```

4. Setup QFeatures object and perform MSqRob analysis

```{r}
sims <- readQFeatures(f0 %>% as.data.frame, ecol = 1:6, name = "sim0")
colData(sims) <- colData(pe)
sims <- msqrob(object = sims, i = "sim0", formula = ~genotype)
sims <- hypothesisTest(object = sims, i = "sim0", contrast = L)

volcano <- ggplot(rowData(sims[["sim0"]])$genotypeD8,
                 aes(x = logFC, y = -log10(pval), color = pval < 0.05)) +
 geom_point(cex = 2.5) +
 scale_color_manual(values = alpha(c("black", "red"), 0.5)) + theme_minimal()
volcano
```

5. Evaluate distribution of the p-values under $H_0$.

```
hist(rowData(sims[["sim0"]])$genotypeD8[,"pval"],main = "simulation H0")

p
sum(rowData(sims[["sim0"]])$genotypeD8$pval < 0.05)
mean(rowData(sims[["sim0"]])$genotypeD8$pval < 0.05)
```

- The p-values are uniform!
- All p-values under the null are equally likely.
- If use p-value cutoff at 0.05 we expect to return 5% of the non-DE proteins  as differentially expressed: many false positives can be expected!

## Pvalue distribution in real experiment

```{r}
hist(rowData(pe[["proteinRobust"]])$genotypeD8[,"pval"],main="realData")
```

- A mixture of null proteins (non-DE): uniform, and, DE proteins: enrichment of p-values at low p-values


# adjusted p-values

- We can adjust the p-values for multiple testing.
- Adjusted P-values with the Benjamini Hochberg correction correspond to the estimated FDR of the set that is returned with all adjusted p-values that are smaller are equal than a certain threshold.

\[F(t) = \pi_0F_0(t) + (1-\pi_0)F_1(t)\]

- p-values? $p = F_0(|T|>|t|)$
- BH-FDR: $\pi_0 = 1$,
$F(t) = \frac{\# \vert t \vert \geq \vert t\vert}{m}$

\begin{eqnarray}
FDR &=& \text{E}\left[\frac{FP}{(FP + TP)}\right]\\
&\approx&\frac{p_0}{\frac{\#p \leq p_0}{m}}\\
&\approx&\frac{p_0 \times m}{\#p \leq p_0}\\
\end{eqnarray}

So adjusted p-value for protein j equals
\[\tilde p_j = \frac{p_{0,j} \times m}{\#p \leq p_{0,j}}\]

However, the FDR always has to be between 0 and 1 so:

\[\tilde p_j = \min\left[\frac{p_{0,j} \times m}{\#p \leq p_{0,j}},1\right]\]

and the adjusted p-values should remain in the same order as the original p-values.

\[\tilde p_j =  \min\limits_{\forall k: p_k > p_j} \min\left[\frac{p_{0,k} \times m}{\#p \leq p_{0,k}},1\right]\]

1. Order pvalues
```{r}
pvals <- rowData(pe[["proteinRobust"]])$genotypeD8[,"pval"]
naInd <- is.na(pvals)
pHlp <- pvals[!naInd]
ord <- pHlp %>% order
pHlp <- pHlp[ord]
```

2. Adjust ordered p-values
```{r}
pHlp <- pHlp*length(pHlp)/(1:length(pHlp))
```

3. Ensure adjust p-values are smaller are equal than 1
```{r}
pHlp[pHlp>1] <- 1
```

4. Monotonicity constraint
```{r}
pmin <- pHlp[length(pHlp)]
for (j in (length(pHlp)-1):1)
{
  if (pHlp[j] < pmin)
    pmin <- pHlp[j] else
    pHlp[j] <- pmin   
}
```

5. Put p-values back in original order

```{r}
pHlp[ord] <- pHlp
pAdj <- pvals
pAdj[!naInd] <- pHlp

head(pAdj)
head(rowData(pe[["proteinRobust"]])$genotypeD8)
range(rowData(pe[["proteinRobust"]])$genotypeD8[,"adjPval"] - pAdj,na.rm=TRUE)
```
